<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Algorand Byzantine Fault Tolerance Protocol Specification</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Algorand Byzantine Fault Tolerance Protocol Specification</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#conventions-and-notation">Conventions and Notation</a></li>
<li><a href="#parameters">Parameters</a></li>
<li><a href="#identity-authorization-and-authentication">Identity, Authorization, and Authentication</a></li>
<li><a href="#the-ledger-of-entries">The Ledger of Entries</a></li>
<li><a href="#messages">Messages</a><ul>
<li><a href="#elementary-data-types">Elementary Data Types</a></li>
<li><a href="#votes">Votes</a></li>
<li><a href="#bundles">Bundles</a></li>
<li><a href="#proposals">Proposals</a></li>
<li><a href="#seed">Seed</a></li>
</ul></li>
<li><a href="#state-machine">State Machine</a><ul>
<li><a href="#events">Events</a></li>
<li><a href="#outputs">Outputs</a></li>
</ul></li>
<li><a href="#player-state-definition">Player State Definition</a><ul>
<li><a href="#special-values">Special Values</a></li>
</ul></li>
<li><a href="#relay-rules">Relay Rules</a><ul>
<li><a href="#votes-1">Votes</a></li>
<li><a href="#bundles-1">Bundles</a></li>
<li><a href="#proposals-1">Proposals</a></li>
</ul></li>
<li><a href="#internal-transitions">Internal Transitions</a><ul>
<li><a href="#new-round">New Round</a></li>
<li><a href="#new-period">New Period</a></li>
<li><a href="#garbage-collection">Garbage Collection</a></li>
<li><a href="#new-step">New Step</a></li>
</ul></li>
<li><a href="#broadcast-rules">Broadcast Rules</a><ul>
<li><a href="#resynchronization-attempt">Resynchronization Attempt</a></li>
<li><a href="#proposals-2">Proposals</a></li>
<li><a href="#reproposal-payloads">Reproposal Payloads</a></li>
<li><a href="#filtering">Filtering</a></li>
<li><a href="#certifying">Certifying</a></li>
<li><a href="#commitment">Commitment</a></li>
<li><a href="#recovery">Recovery</a></li>
<li><a href="#fast-recovery">Fast Recovery</a></li>
</ul></li>
</ul>
</nav>
<h1 id="conventions-and-notation">Conventions and Notation</h1>
<p>This specification defines a <em>player</em> to be a unique participant in this protocol.</p>
<p>This specification describes the operation of a single <em>correct</em> player. A correct player follows this protocol exactly and is distinct from a <em>faulty</em> player. A faulty player may deviate from the protocol in any way, so this specification does not describe the behavior of those players.</p>
<p>Correct players do not follow distinct protocols, so this specification describes correct behavior with respect to a single, implicit player. When the protocol must describe a player distinct from the implicit player (for example, a message which originated from another player), the protocol will use subscripts to distinguish different players. Subscripts are omitted when the player is unambiguous. For instance, a player might be associated with some ``address’’ <span class="math inline">\(I\)</span>; if this player is the <span class="math inline">\(k\)</span>th player in the protocol, then this address may also be denoted <span class="math inline">\(I_k\)</span>.</p>
<p>This specification will describe certain objects as <em>opaque</em>. This document does not specify the exact implementation of opaque objects, but it does specify the subset of properties required of any implementation of some opaque object.</p>
<p>Opaque data definitions and semantics may be specified in other documents, which this document will cite when available.</p>
<p>All integers described in this document are unsigned.</p>
<h1 id="parameters">Parameters</h1>
<p>The protocol is parameterized by the following constants:</p>
<ul>
<li><span class="math inline">\(\lambda, \lambda_f, \Lambda\)</span> are values representing durations of time.</li>
<li><span class="math inline">\(\delta_s, \delta_r\)</span> are positive integers (the “seed lookback” and “seed refresh interval”).</li>
</ul>
<p>For convenience, we define <span class="math inline">\(\delta_b\)</span> (the “balance lookback”) to be <span class="math inline">\(2\delta_s\delta_r\)</span>.</p>
<p>Algorand v1 sets <span class="math inline">\(\delta_s = 2\)</span>, <span class="math inline">\(\delta_r = 80\)</span>, <span class="math inline">\(\lambda = 4\)</span> seconds, <span class="math inline">\(\lambda_f = 5\)</span> minutes, and <span class="math inline">\(\Lambda = 17\)</span> seconds.</p>
<h1 id="identity-authorization-and-authentication">Identity, Authorization, and Authentication</h1>


<p>A player is uniquely identified by a 256-bit string <span class="math inline">\(I\)</span> called an <em>address</em>.</p>
<p>Each player owns exactly one <em>participation keypair</em>. A participation keypair consists of a <em>public key</em> <span class="math inline">\(\mathrm{pk}\)</span> and a <em>secret key</em> <span class="math inline">\(\mathrm{sk}\)</span>. A keypair is an opaque object which is defined in the <a href="https://github.com/algorand/spec/partkey.md">specification of participation keys in Algorand</a>.</p>
<p>Let <span class="math inline">\(m, m&#39;\)</span> be arbitrary sequences of bits, <span class="math inline">\(B_k, \bar{B}\)</span> be 64-bit integers, <span class="math inline">\(\tau, \bar{\tau}\)</span> be 32-bit integers, and <span class="math inline">\(Q\)</span> be a 256-bit string. Let <span class="math inline">\((\mathrm{pk}_k, \mathrm{sk}_k)\)</span> be some valid keypair.</p>
<p>A secret key supports a <em>signing</em> procedure <span class="math display">\[
y := \mathrm{Sign}(m, m&#39;, \mathrm{sk}_k, B_k, \bar{B}, Q, \tau, \bar{\tau})
\]</span> where <span class="math inline">\(y\)</span> is opaque and are cryptographically resistant to tampering, where defined. Signing is not defined on many inputs: for any given input, signing may fail to produce an output.</p>
<p>The following functions are defined on <span class="math inline">\(y\)</span>:</p>
<ul>
<li><p><em>Verifying</em>: <span class="math inline">\(\mathrm{Verify}(y, m, m&#39;, \mathrm{pk}_k, B_k, \bar{B}, Q, \tau, \bar{\tau}) = w\)</span>, where <span class="math inline">\(w\)</span> is a 64-bit integer called the <em>weight</em> of <span class="math inline">\(y\)</span>. <span class="math inline">\(w \neq 0\)</span> if and only if <span class="math inline">\(y\)</span> was produced by signing by <span class="math inline">\(\mathrm{sk}_k\)</span> (up to cryptographic security). <span class="math inline">\(w\)</span> is uniquely determined given fixed values of <span class="math inline">\(m&#39;, \mathrm{pk}_k, B_k, \bar{B}, Q, \tau, \bar{\tau}\)</span>.</p></li>
<li><p><em>Comparing</em>: Fixing the inputs <span class="math inline">\(m&#39;, \bar{B}, Q, \tau, \bar{\tau}\)</span> to a signing operation, there exists a total ordering on the outputs <span class="math inline">\(y\)</span>. In other words, if <span class="math inline">\(f(\mathrm{sk}, B) = \mathrm{Sign}(m, m&#39;, \mathrm{sk}, B, \bar{B}, Q, \tau, \bar{\tau}) = y\)</span>, and <span class="math inline">\(S = \{(\mathrm{sk}_0, B_0), (\mathrm{sk}_1, B_1), \ldots, (\mathrm{sk}_n, B_n)\}\)</span>, then <span class="math inline">\(\{f(x) | x \in S\}\)</span> is a totally ordered set. We write that <span class="math inline">\(y_1 &lt; y_2\)</span> if <span class="math inline">\(y_1\)</span> comes before <span class="math inline">\(y_2\)</span> in this ordering.</p></li>
<li><p><em>Generating Randomness</em>: Let <span class="math inline">\(y\)</span> be a valid output of a signing operation with <span class="math inline">\(\mathrm{sk}_k\)</span>. Then <span class="math inline">\(r = \mathrm{Rand}(y, \mathrm{pk}_k)\)</span> is defined to be a pseudorandom 256-bit integer (up to cryptographic security). <span class="math inline">\(r\)</span> is uniquely determined given fixed values of <span class="math inline">\(m&#39;, \mathrm{pk}_k, B_k, \bar{B}, Q, \tau, \bar{\tau}\)</span>.</p></li>
</ul>
<p>The signing procedure is allowed to produce a nondeterministic output, but the functions above must be well-defined with respect to a given input to the signing procedure (e.g., a procedure that implements <span class="math inline">\(\mathrm{Verify}(\mathrm{Sign}(\ldots))\)</span> always returns the same value).</p>
<h1 id="the-ledger-of-entries">The Ledger of Entries</h1>



<p>An <em>entry</em> is a pair <span class="math inline">\(e = (o, Q)\)</span> where <span class="math inline">\(o\)</span> is some opaque object, and <span class="math inline">\(Q\)</span> is a 256-bit integer called a <em>seed</em>.</p>
<p>The following functions are defined on <span class="math inline">\(e\)</span>:</p>
<ul>
<li><p><em>Encoding</em>: <span class="math inline">\(\mathrm{Encoding}(e) = x\)</span> where <span class="math inline">\(x\)</span> is a variable-length bitstring.</p></li>
<li><p><em>Summarizing</em>: <span class="math inline">\(\mathrm{Digest}(e) = h\)</span> where <span class="math inline">\(h\)</span> is a 256-bit integer. (<span class="math inline">\(h\)</span> should be a cryptographic commitment to the contents of <span class="math inline">\(e\)</span>.)</p></li>
</ul>
<p>A <em>ledger</em> is a sequence of entries <span class="math inline">\(L = (e_1, e_2, \ldots, e_n)\)</span>. A <em>round</em> <span class="math inline">\(r\)</span> is some 64-bit index into this sequence.</p>
<p>The following functions are defined on <span class="math inline">\(L\)</span>:</p>
<ul>
<li><p><em>Validating</em>: <span class="math inline">\(\mathrm{ValidEntry}(L, o) = 1\)</span> if and only if <span class="math inline">\(o\)</span> is <em>valid with respect to <span class="math inline">\(L\)</span></em>. This validity property is opaque.</p></li>
<li><p><em>Seed Lookup</em>: If <span class="math inline">\(e_r = (o_r, Q_r)\)</span>, then <span class="math inline">\(\mathrm{Seed}(L, r)\)</span> = <span class="math inline">\(Q_r\)</span>.</p></li>
<li><p><em>Record Lookup</em>: <span class="math inline">\(\mathrm{Record}(L, r, I_k) = (\mathrm{pk}_{k,r}, B_{k,r})\)</span> for some address <span class="math inline">\(I_k\)</span>, some public key <span class="math inline">\(\mathrm{pk}_{k,r}\)</span>, and some 64-bit integer <span class="math inline">\(B_{k,r}\)</span>.</p></li>
<li><p><em>Digest Lookup</em>: <span class="math inline">\(\mathrm{DigestLookup}(L, r) = \mathrm{Digest}(e_r)\)</span>.</p></li>
<li><p><em>Total Stake Lookup</em>: <span class="math inline">\(\mathrm{Stake}(L, r) = \sum_k \mathrm{Record}(L, r, I_k)\)</span>.</p></li>
</ul>
<p>A ledger may support an opaque <em>entry generation</em> procedure <span class="math display">\[
o := \mathrm{Entry}(L, Q)
\]</span> which produces an object <span class="math inline">\(o\)</span> for which <span class="math inline">\(\mathrm{ValidEntry}(L, o) = 1\)</span>.</p>
<h1 id="messages">Messages</h1>
<p>Players communicate with each other by exchanging <em>messages</em>.</p>
<h2 id="elementary-data-types">Elementary Data Types</h2>



<p>A <em>period</em> <span class="math inline">\(p\)</span> is a 64-bit integer.</p>
<p>A <em>step</em> <span class="math inline">\(s\)</span> is an 8-bit integer. Certain steps are named for clarity. These steps are defined as follows:</p>
<ul>
<li><span class="math inline">\(\mathit{propose}= 0\)</span></li>
<li><span class="math inline">\(\mathit{soft}= 1\)</span></li>
<li><span class="math inline">\(\mathit{cert}= 2\)</span></li>
<li><span class="math inline">\(\mathit{late}= 253\)</span></li>
<li><span class="math inline">\(\mathit{redo}= 254\)</span></li>
<li><span class="math inline">\(\mathit{down}= 255\)</span></li>
<li><span class="math inline">\(\mathit{next}_s = s+3\)</span></li>
</ul>
<p>The following functions are defined on <span class="math inline">\(s\)</span>:</p>
<ul>
<li><em>Committee Size</em>: <span class="math inline">\(\mathrm{CommitteeSize}(s)\)</span> is a 64-bit integer defined as follows: <span class="math display">\[
\mathrm{CommitteeSize}(s) = \left\{
\begin{array}{rl}
   9 &amp; : s = \mathit{propose}\\
2990 &amp; : s = \mathit{soft}\\
1500 &amp; : s = \mathit{cert}\\
 500 &amp; : s = \mathit{late}\\
2400 &amp; : s = \mathit{redo}\\
6000 &amp; : s = \mathit{down}\\
5000 &amp; : \text{otherwise}
\end{array}
\right.
\]</span></li>
<li><em>Committee Threshold</em>: <span class="math inline">\(\mathrm{CommitteeThreshold}(s)\)</span> is a 64-bit integer defined as follows: <span class="math display">\[
\mathrm{CommitteeThreshold}(s) = \left\{
\begin{array}{rl}
  0 &amp; : s = \mathit{propose}\\
  2267 &amp; : s = \mathit{soft}\\
  1112 &amp; : s = \mathit{cert}\\
320 &amp; : s = \mathit{late}\\
  1768 &amp; : s = \mathit{redo}\\
  4560 &amp; : s = \mathit{down}\\
  3838 &amp; : \text{otherwise}
\end{array}
\right.
\]</span></li>
</ul>
<p>A <em>proposal-value</em> is a tuple <span class="math inline">\(v = (I, p, \mathrm{Digest}(e), \mathrm{Hash}(\mathrm{Encoding}(e)))\)</span> where <span class="math inline">\(I\)</span> is an address (the “original proposer”), <span class="math inline">\(p\)</span> is a period (the “original period”), and <span class="math inline">\(\mathrm{Hash}\)</span> is some cryptographic hash function. The special proposal where all fields are the zero-string is called the bottom proposal <span class="math inline">\(\bot\)</span>.</p>
<h2 id="votes">Votes</h2>

<p>Let <span class="math inline">\(I\)</span> be an address, <span class="math inline">\(r\)</span> be a round, <span class="math inline">\(p\)</span> be a period, <span class="math inline">\(s\)</span> be a step, and <span class="math inline">\(v\)</span> be a proposal-value, let <span class="math inline">\(x\)</span> be a canonical encoding of the 5-tuple <span class="math inline">\((I, r, p, s, v)\)</span>, and let <span class="math inline">\(x&#39;\)</span> be a canonical encoding of the 4-tuple <span class="math inline">\((I, r, p, s)\)</span>. Let <span class="math inline">\(y\)</span> be an arbitrary bitstring. Then we say that the tuple <span class="math display">\[
(I, r, p, s, v, y)
\]</span> is a <em>vote from <span class="math inline">\(I\)</span> for <span class="math inline">\(v\)</span> at round <span class="math inline">\(r\)</span>, period <span class="math inline">\(p\)</span>, step <span class="math inline">\(s\)</span></em> (or <em>a vote from <span class="math inline">\(I\)</span> for <span class="math inline">\(v\)</span> at <span class="math inline">\((r, p, s)\)</span></em>), denoted <span class="math inline">\(\mathrm{Vote}(I, r, p, s, v)\)</span>.</p>
<p>Moreover, let <span class="math inline">\(L\)</span> be a ledger where <span class="math inline">\(|L| \geq \delta_b\)</span>. Let <span class="math inline">\((\mathrm{sk}, \mathrm{pk})\)</span> be a keypair, <span class="math inline">\(B, \bar{B}\)</span> be 64-bit integers, <span class="math inline">\(Q\)</span> be a 256-bit integer, and <span class="math inline">\(\tau, \bar{\tau}\)</span> 32-bit integers. We say that this vote is <em>valid with respect to <span class="math inline">\(L\)</span></em> (or simply <em>valid</em> if <span class="math inline">\(L\)</span> is unambiguous) if the following conditions are true:</p>
<ul>
<li><p><span class="math inline">\(r \leq |L| + 2\)</span></p></li>
<li><p>Let <span class="math inline">\(v = (I_{orig}, p_{orig}, d, h)\)</span>. If <span class="math inline">\(s = 0\)</span>, then <span class="math inline">\(p_{orig} \le p\)</span>. Furthermore, if <span class="math inline">\(s = 0\)</span> and <span class="math inline">\(p = p_{orig}\)</span>, then <span class="math inline">\(I = I_{orig}\)</span>.</p></li>
<li><p>If <span class="math inline">\(s \in \{\mathit{propose}, \mathit{soft}, \mathit{cert}, \mathit{late}, \mathit{redo}\}\)</span>, <span class="math inline">\(v \neq \bot\)</span>. Conversely, if <span class="math inline">\(s = \mathit{down}\)</span>, <span class="math inline">\(v = \bot\)</span>.</p></li>
<li><p>Let <span class="math inline">\((\mathrm{pk}, B) = (\mathrm{Record}(L, r - \delta_b), I)\)</span>, <span class="math inline">\(\bar{B}= \mathrm{Stake}(L, r - \delta_b)\)</span>, <span class="math inline">\(Q = \mathrm{Seed}(L, r - \delta_s)\)</span>, <span class="math inline">\(\tau = \mathrm{CommitteeThreshold}(s)\)</span>, and <span class="math inline">\(\bar{\tau}= \mathrm{CommitteeSize}(s)\)</span>.<br />
Then <span class="math inline">\(\mathrm{Verify}(y, x, x&#39;, \mathrm{pk}, B, \bar{B}, Q, \tau, \bar{\tau}) \neq 0\)</span>.</p></li>
</ul>
<p>Observe that valid votes contain outputs of the <span class="math inline">\(\mathrm{Sign}\)</span> procedure; i.e., <span class="math inline">\(y := \mathrm{Sign}(x, x&#39;, \mathrm{sk}, B, \bar{B}, Q, \tau, \bar{\tau})\)</span>.</p>
<p>Informally, these conditions check the following:</p>
<ul>
<li><p>The vote is not too far in the future for <span class="math inline">\(L\)</span> to be able to validate.</p></li>
<li><p>“Propose”-step votes can either propose a new proposal-value for this period (<span class="math inline">\(p_{orig} = p\)</span>) or claim to “re-propose” a value originally proposed in an earlier period (<span class="math inline">\(p_{orig} &lt; p\)</span>). But they can’t claim to “re-propose” a value from a future period. And if the proposal-value is new (<span class="math inline">\(p_{orig} = p\)</span>) then the “original proposer” must be the voter.</p></li>
<li><p>The <span class="math inline">\(\mathit{propose}\)</span>, <span class="math inline">\(\mathit{soft}\)</span>, <span class="math inline">\(\mathit{cert}\)</span>, <span class="math inline">\(\mathit{late}\)</span>, and <span class="math inline">\(\mathit{redo}\)</span> steps must vote for an actual proposal. The <span class="math inline">\(\mathit{down}\)</span> step must only vote for <span class="math inline">\(\bot\)</span>.</p></li>
<li><p>The last condition checks that the vote was properly signed by a voter who was selected to serve on the committee for this round, period, and step, where the committee selection process uses the voter’s stake and keys as of <span class="math inline">\(\delta_b\)</span> rounds before the vote.</p></li>
</ul>
<p>An <em>equivocation vote pair</em> or <em>equivocation vote</em> <span class="math inline">\(\mathrm{Equivocation}(I, r, p, s)\)</span> is a pair of votes which differ in their proposal values. In other words, <span class="math display">\[
\begin{aligned}
\mathrm{Equivocation}(I, r, p, s)
 = (&amp;\mathrm{Vote}(I, r, p, s, v_1), \\
    &amp;\mathrm{Vote}(I, r, p, s, v_2))
\end{aligned}
\]</span> for some <span class="math inline">\(v_1 \neq v_2\)</span>.</p>
<p>An equivocation vote pair is <em>valid with respect to <span class="math inline">\(L\)</span></em> (or simply <em>valid</em> if <span class="math inline">\(L\)</span> is unambiguous) if both of its constituent votes are also valid with respect to <span class="math inline">\(L\)</span>.</p>
<h2 id="bundles">Bundles</h2>

<p>Let <span class="math inline">\(V\)</span> be any set of votes and equivocation votes. We say that <span class="math inline">\(V\)</span> <em>is a bundle for <span class="math inline">\(v\)</span> in round <span class="math inline">\(r\)</span>, period <span class="math inline">\(p\)</span>, and step <span class="math inline">\(s\)</span></em> (or a <em>bundle for <span class="math inline">\(v\)</span> at <span class="math inline">\((r, p, s)\)</span></em>), denoted <span class="math inline">\(\mathrm{Bundle}(r, p, s, v)\)</span>.</p>
<p>Moreover, let <span class="math inline">\(L\)</span> be a ledger where <span class="math inline">\(|L| \geq \delta_b\)</span>. We say that this bundle is <em>valid with respect to <span class="math inline">\(L\)</span></em> (or simply <em>valid</em> if <span class="math inline">\(L\)</span> is unambiguous) if the following conditions are true:</p>
<ul>
<li><p>Every element <span class="math inline">\(a_i \in V\)</span> is valid with respect to <span class="math inline">\(L\)</span>.</p></li>
<li><p>For any two elements <span class="math inline">\(a_i, a_j \in V\)</span>, <span class="math inline">\(I_i \neq I_j\)</span>.</p></li>
<li><p>For any element <span class="math inline">\(a_i \in V\)</span>, <span class="math inline">\(r_i = r, p_i = p, s_i = s\)</span>.</p></li>
<li><p>For any element <span class="math inline">\(a_i \in V\)</span>, either <span class="math inline">\(a_i\)</span> is a vote and <span class="math inline">\(v_i = v\)</span>, or <span class="math inline">\(a_i\)</span> is an equivocation vote.</p></li>
<li><p>Let <span class="math inline">\(w_i\)</span> be the weight of the signature in <span class="math inline">\(a_i\)</span>. Then <span class="math inline">\(\sum_i w_i \geq \mathrm{CommitteeThreshold}(s)\)</span>.</p></li>
</ul>
<h2 id="proposals">Proposals</h2>

<p>Let <span class="math inline">\(e = (o, s)\)</span> be an entry and <span class="math inline">\(y\)</span> be the output of a <span class="math inline">\(\mathrm{Sign}\)</span> procedure. The pair <span class="math inline">\((e, y)\)</span> is a <em>proposal</em> or a <em>proposal payload</em>.</p>
<p>Moreover, let <span class="math inline">\(L\)</span> be a ledger where <span class="math inline">\(|L| \geq \delta_b\)</span>, and let <span class="math inline">\(v = (I, p, h, x)\)</span> be some proposal-value. We say that this proposal is <em>a valid proposal matching <span class="math inline">\(v\)</span> with respect To <span class="math inline">\(L\)</span></em> (or simply that this proposal <em>matches <span class="math inline">\(v\)</span></em> if <span class="math inline">\(L\)</span> is unambiguous) if the following conditions are true:</p>
<ul>
<li><p><span class="math inline">\(\mathrm{ValidEntry}(L, e) = 1\)</span>.</p></li>
<li><p><span class="math inline">\(h = \mathrm{Digest}(e)\)</span>.</p></li>
<li><p><span class="math inline">\(x = \mathrm{Hash}(\mathrm{Encoding}(e))\)</span>.</p></li>
<li><p>The seed <span class="math inline">\(s\)</span> and seed proof are valid as specified in the following section.</p></li>
<li><p>Let <span class="math inline">\((B, \mathrm{pk}) = \mathrm{Record}(L, r - \delta_b, I)\)</span>. If <span class="math inline">\(p = 0\)</span>, then <span class="math inline">\(\mathrm{Verify}(y, Q_0, Q_0, \mathrm{pk}, 0, 0, 0, 0, 0) \neq 0\)</span>.</p></li>
</ul>
<p>If <span class="math inline">\(e\)</span> matches <span class="math inline">\(v\)</span>, we write <span class="math inline">\(e = \mathrm{Proposal}(v)\)</span>.</p>
<h2 id="seed">Seed</h2>
<p>Informally, the protocol interleaves <span class="math inline">\(\delta_s\)</span> seeds in an alternating sequence. Each seed is derived from a seed <span class="math inline">\(\delta_s\)</span> rounds in the past through either a hash function or through a VRF, keyed on the entry proposer. Additionally, every <span class="math inline">\(\delta_r\)</span> rounds, the digest of a previous entry (specifically, from round <span class="math inline">\(r - \delta_r\)</span>) is hashed into the result. The seed proof is the corresponding VRF proof, or 0 if the VRF was not used.</p>
<p>More formally, suppose <span class="math inline">\(I\)</span> is a correct proposer in round <span class="math inline">\(r\)</span> and period <span class="math inline">\(p\)</span>. Let <span class="math inline">\((B, \mathrm{pk}) = \mathrm{Record}(L, r - \delta_b, I)\)</span> and <span class="math inline">\(\mathrm{sk}\)</span> be the secret key corresponding to <span class="math inline">\(\mathrm{pk}\)</span>. Let <span class="math inline">\(\alpha\)</span> be a 256-bit integer. Then <span class="math inline">\(I\)</span> computes the seed proof <span class="math inline">\(y\)</span> for a new entry as follows:</p>
<ul>
<li>If <span class="math inline">\(p = 0\)</span>:
<ul>
<li><span class="math inline">\(y = \mathrm{VRF.Prove}(\mathrm{Seed}(L, r-\delta_s), \mathrm{sk})\)</span></li>
<li><span class="math inline">\(\alpha = \mathrm{Hash}(\mathrm{VRF.ProofToHash}(y), I)\)</span></li>
</ul></li>
<li>If <span class="math inline">\(p \ne 0\)</span>:
<ul>
<li><span class="math inline">\(y = 0\)</span></li>
<li><span class="math inline">\(\alpha = \mathrm{Hash}(\mathrm{Seed}(L, r-\delta_s))\)</span></li>
</ul></li>
</ul>
<p>Now <span class="math inline">\(I\)</span> computes the seed <span class="math inline">\(Q\)</span> as follows: <span class="math display">\[
Q = \left\{
\begin{array}{rl}
  H(\alpha, \mathrm{DigestLookup}(L, r-\delta_s\delta_r)) &amp; : (r \bmod \delta_s\delta_r) &lt; \delta_s \\
  H(\alpha) &amp; : \text{otherwise}
\end{array}
\right.
\]</span></p>
<p>The seed is valid if the following verification procedure succeeds:</p>
<ol type="1">
<li><p>Let <span class="math inline">\((B, \mathrm{pk}) = \mathrm{Record}(L, r - \delta_b, I)\)</span>; let <span class="math inline">\(q_0 = \mathrm{Seed}(L, r-1)\)</span>.</p></li>
<li><p>If <span class="math inline">\(p = 0\)</span>, check <span class="math inline">\(\mathrm{VRF.Verify}(y, q_0, \mathrm{pk})\)</span>, immediately returning failure if verification fails. Let <span class="math inline">\(q_1 = \mathrm{Hash}(\mathrm{VRF.ProofToHash}(y), I)\)</span> and continue to step 4.</p></li>
<li><p>If <span class="math inline">\(p \ne 0\)</span>, let <span class="math inline">\(q_1 = \mathrm{Hash}(q_0)\)</span>. Continue.</p></li>
<li><p>If <span class="math inline">\(r \equiv (r \bmod \delta_s) \mod \delta_r\delta_s\)</span>, then check <span class="math inline">\(Q = \mathrm{Hash}(q_1, \mathrm{DigestLookup}(L, r-\delta_s\delta_r))\)</span>. Otherwise, check <span class="math inline">\(Q = q_1\)</span>.</p></li>
</ol>
<p>Note: Round <span class="math inline">\(r\)</span> leader selection and committee selection both use the seed from <span class="math inline">\(r - \delta_s\)</span> and the balances / public keys from <span class="math inline">\(r - \delta_b\)</span>.</p>
<p>Note: For reproposals, the period <span class="math inline">\(p\)</span> used in this section is the <em>original</em> period, not the reproposal period.</p>
<h1 id="state-machine">State Machine</h1>

<p>This specification defines the Algorand agreement protocol as a state machine. The input to the state machine is some serialization of events, which in turn results in some serialization of network transmissions from the state machine.</p>
<p>We can define the operation of the state machine as transitions between different states. A transition <span class="math inline">\(N\)</span> maps some initial state <span class="math inline">\(S_0\)</span>, a ledger <span class="math inline">\(L_0\)</span>, and an event <span class="math inline">\(e\)</span> to an output state <span class="math inline">\(S_1\)</span>, an output ledger <span class="math inline">\(L_1\)</span>, and a sequence of output network transmissions <span class="math inline">\(\mathbf{a}= (a_1, a_2, \ldots, a_n)\)</span>. We write this as <span class="math display">\[
N(S_0, L_0, e) = (S_1, L_1, \mathbf{a}).
\]</span> If no transmissions are output, we write that <span class="math inline">\(\mathbf{a}= \epsilon\)</span>.</p>
<h2 id="events">Events</h2>
<p>The state machine <em>receives</em> two types of events as inputs.</p>
<ol type="1">
<li><em>message events</em>: A message event is received when a vote, a proposal, or a bundle is received. A message event is simply written as the message that is received.</li>
<li><em>timeout events</em>: A timeout event is received when a specific amount of time passes after the beginning of a period. A timeout event <span class="math inline">\(\lambda\)</span> seconds after period <span class="math inline">\(p\)</span> begins is denoted <span class="math inline">\(t(\lambda, p)\)</span>.</li>
</ol>
<h2 id="outputs">Outputs</h2>
<p>The state machine produces a series of network transmissions as output. In each transmission, the player broadcasts a vote, a proposal, or a bundle to the rest of the network.</p>
<p>A player may perform a special broadcast called a <em>relay</em>. In a relay, the data received from another peer is broadcast to all peers except for the sender.</p>
<p>A broadcast action is simply written as the message to be transmitted. A relay action is written as the same message except with an asterisk. For instance, an action to relay a vote is written as <span class="math inline">\(\mathrm{Vote}^*(r, p, s, v)\)</span>.</p>
<h1 id="player-state-definition">Player State Definition</h1>

<p>We define the <em>player state</em> <span class="math inline">\(S\)</span> to be the following tuple: <span class="math display">\[
S = (r, p, s, \bar{s}, V, P, \bar{v})
\]</span> where</p>
<ul>
<li><span class="math inline">\(r\)</span> is the current round,</li>
<li><span class="math inline">\(p\)</span> is the current period,</li>
<li><span class="math inline">\(s\)</span> is the current step,</li>
<li><span class="math inline">\(\bar{s}\)</span> is the <em>last concluding step</em>,</li>
<li><span class="math inline">\(V\)</span> is the set of all votes,</li>
<li><span class="math inline">\(P\)</span> is the set of all proposals, and</li>
<li><span class="math inline">\(\bar{v}\)</span> is the <em>pinned</em> value.</li>
</ul>
<p>We say that a player has <em>observed</em></p>
<ul>
<li><span class="math inline">\(\mathrm{Proposal}(v)\)</span> if <span class="math inline">\(\mathrm{Proposal}(v) \in P\)</span></li>
<li><span class="math inline">\(\mathrm{Vote}_l(r, p, s, v)\)</span> if <span class="math inline">\(\mathrm{Vote}_l(r, p, s, v) \in V\)</span></li>
<li><span class="math inline">\(\mathrm{Bundle}(r, p, s, v)\)</span> if <span class="math inline">\(\mathrm{Bundle}_l(r, p, s, v) \subset V\)</span></li>
<li>that round <span class="math inline">\(r\)</span> (period 0) has <em>begun</em> if there exists some <span class="math inline">\(p\)</span> such that <span class="math inline">\(\mathrm{Bundle}(r-1, p, \mathit{cert}, v)\)</span> was also observed</li>
<li>that round <span class="math inline">\(r\)</span>, period <span class="math inline">\(p &gt; 0\)</span> has <em>begun</em> if there exists some <span class="math inline">\(p\)</span> such that either
<ul>
<li><span class="math inline">\(\mathrm{Bundle}(r, p-1, s, v)\)</span> was also observed for some <span class="math inline">\(s &gt; \mathit{cert}, v\)</span>, or</li>
<li><span class="math inline">\(\mathrm{Bundle}(r, p, \mathit{soft}, v)\)</span> was observed for some <span class="math inline">\(v\)</span>.</li>
</ul></li>
</ul>
<p>An event causes a player to observe something if the player has not observed that thing before receiving the event and has observed that thing after receiving the event. For instance, a player may observe a vote <span class="math inline">\(\mathrm{Vote}\)</span>, which adds this vote to <span class="math inline">\(V\)</span>: <span class="math display">\[
 N((r, p, s, \bar{s}, V, P, \bar{v}), L_0, \mathrm{Vote})
= ((r&#39;, p&#39;, \ldots, V \cup \{\mathrm{Vote}\}, P, \bar{v}&#39;), L_1, \ldots).
\]</span> We abbreviate the transition above as <span class="math display">\[
 N((r, p, s, \bar{s}, V, P, \bar{v}), L_0, \mathrm{Vote})
 = ((S \cup \mathrm{Vote}, P, \bar{v}), L_1, \ldots).
\]</span> Note that <em>observing</em> a message is distinct from <em>receiving</em> a message. A message which has been received might not be observed (for instance, the message may be from an old round). Refer to the <a href="#relay-rules">relay rules</a> for details.</p>
<h2 id="special-values">Special Values</h2>
<p>We define two functions <span class="math inline">\(\mu(S, r, p), \sigma(S, r, p)\)</span>, which are defined as follows:</p>
<p><span class="math inline">\(\mu(S, r, p)\)</span> is defined as the proposal-value in the vote in round <span class="math inline">\(r\)</span> and period <span class="math inline">\(p\)</span> with the minimal credential. More formally, let <span class="math display">\[
V_{r, p} = \{\mathrm{Vote}(I, r, p, 0, v) | \mathrm{Vote}\in V\}
\]</span> where <span class="math inline">\(V\)</span> is the set of votes in <span class="math inline">\(S\)</span>. Then if <span class="math inline">\(\mathrm{Vote}_l(r, p, 0, v_l)\)</span> is the vote with the smallest weight in <span class="math inline">\(V_{r, p}\)</span>, then <span class="math inline">\(\mu(S, r, p) = v_l\)</span>.</p>
<p>If <span class="math inline">\(V_{r, p}\)</span> is empty, then <span class="math inline">\(\mu(S, r, p) = \bot\)</span>.</p>
<p><span class="math inline">\(\sigma(S, r, p)\)</span> is defined as the sole proposal-value for which there exists a soft-bundle in round <span class="math inline">\(r\)</span> and period <span class="math inline">\(p\)</span>. More formally, suppose <span class="math inline">\(\mathrm{Bundle}(r, p, \mathit{soft}, v) \subset V\)</span>. Then <span class="math inline">\(\sigma(S, r, p) = v\)</span>.</p>
<p>If no such soft-bundle exists, then <span class="math inline">\(\sigma(S, r, p) = \bot\)</span>.</p>
<p>If there exists a proposal-value <span class="math inline">\(v\)</span> such that <span class="math inline">\(\mathrm{Proposal}(v) \in V\)</span> and <span class="math inline">\(\sigma(S, r, p) = v\)</span>, we say that <span class="math inline">\(v\)</span> is <em>committable for round <span class="math inline">\(r\)</span>, period <span class="math inline">\(p\)</span></em> (or simply that <span class="math inline">\(v\)</span> is <em>committable</em> if <span class="math inline">\((r, p)\)</span> is unambiguous).</p>
<h1 id="relay-rules">Relay Rules</h1>
<p>Here we describe how players handle message events.</p>
<p>Whenever the player receives a message event, it may decide to <em>relay</em> that or another message. In this case, the player will produce that output before producing any subsequent output (which may result from the player’s observation of that message; see the <a href="#broadcast-rules">broadcast rules</a> below).</p>
<p>A player may receive messages from a peer which indicates that the peer is misbehaving. These cases are marked with an asterisk (*) and enable the node to perform a special action (e.g., disconnect from the peer).</p>
<p>We say that a player <em>ignores</em> a message if it produces no outputs on receiving that message.</p>
<h2 id="votes-1">Votes</h2>
<p>On receiving a vote <span class="math inline">\(Vote_k(r_k, p_k, s_k, v)\)</span> a player</p>
<ul>
<li>Ignores* it if <span class="math inline">\(\mathrm{Vote}_k\)</span> is invalid.</li>
<li>Ignores it if <span class="math inline">\(s = 0\)</span> and <span class="math inline">\(\mathrm{Vote}_k \in V\)</span>.</li>
<li>Ignores it if <span class="math inline">\(s = 0\)</span> and <span class="math inline">\(\mathrm{Vote}_k\)</span> is an equivocation.</li>
<li>Ignores it if <span class="math inline">\(s &gt; 0\)</span> and <span class="math inline">\(\mathrm{Vote}_k\)</span> is a second equivocation.</li>
<li>Ignores it if
<ul>
<li><span class="math inline">\(r_k \notin [r,r+1]\)</span> or</li>
<li><span class="math inline">\(r_k = r + 1\)</span> and either
<ul>
<li><span class="math inline">\(p_k &gt; 0\)</span> or</li>
<li><span class="math inline">\(s_k \in (\mathit{next}_0, \mathit{late})\)</span> or</li>
</ul></li>
<li><span class="math inline">\(r_k = r\)</span> and one of
<ul>
<li><span class="math inline">\(p_k \notin [p-1,p+1]\)</span> or</li>
<li><span class="math inline">\(p_k = p + 1\)</span> and <span class="math inline">\(s_k \in (\mathit{next}_0, \mathit{late})\)</span> or</li>
<li><span class="math inline">\(p_k = p\)</span> and <span class="math inline">\(s_k \in (\mathit{next}_0, \mathit{late})\)</span> and <span class="math inline">\(s_k \notin [s-1,s+1]\)</span> or</li>
<li><span class="math inline">\(p_k = p - 1\)</span> and <span class="math inline">\(s_k \in (\mathit{next}_0, \mathit{late})\)</span> and <span class="math inline">\(s_k \notin [\bar{s}-1,\bar{s}+1]\)</span>.</li>
</ul></li>
</ul></li>
<li>Otherwise, relays <span class="math inline">\(\mathrm{Vote}_k\)</span>, observes it, and then produces any consequent output.</li>
</ul>
<p>Specifically, if a player ignores the vote, <span class="math display">\[
N(S, L, \mathrm{Vote}_k(r_k, p_k, s_k, v)) = (S, L, \epsilon)
\]</span> while if a player relays the vote, <span class="math display">\[
 N(S, L, \mathrm{Vote}_k(r_k, p_k, s_k, v))
= (S&#39; \cup \mathrm{Vote}(I, r_k, p_k, s_k, v), L&#39;,
   (\mathrm{Vote}_k^*(r_k, p_k, s_k, v),\ldots)).
\]</span></p>
<h2 id="bundles-1">Bundles</h2>
<p>On receiving a bundle <span class="math inline">\(\mathrm{Bundle}(r_k, p_k, s_k, v)\)</span> a player</p>
<ul>
<li>Ignores* it if <span class="math inline">\(\mathrm{Bundle}(r, p, s, v)\)</span> is invalid.</li>
<li>Ignores it if
<ul>
<li><span class="math inline">\(r_k \neq r\)</span> or</li>
<li><span class="math inline">\(r_k = r\)</span> and <span class="math inline">\(p_k + 1 &lt; p\)</span>.</li>
</ul></li>
<li>Otherwise, observes the votes in <span class="math inline">\(\mathrm{Bundle}(r_k, p_k, s_k, v)\)</span> in sequence. If there exists a vote which causes the player to observe some bundle <span class="math inline">\(\mathrm{Bundle}(r_k, p_k, s_k, v&#39;)\)</span> for some <span class="math inline">\(s_k\)</span>, then the player relays <span class="math inline">\(\mathrm{Bundle}(r_k, p_k, s_k, v&#39;)\)</span>, and then executes any consequent action; if there does not, the player ignores it.</li>
</ul>
<p>Specifically, if the player ignores the bundle without observing its votes, <span class="math display">\[
N(S, L, \mathrm{Bundle}(r_k, p_k, s_k, v)) = (S, L, \epsilon);
\]</span> while if a player ignores the bundle but observes its votes, <span class="math display">\[
N(S, L, \mathrm{Bundle}(r_k, p_k, s_k, v))
= (S&#39; \cup \mathrm{Bundle}(r_k, p_k, s_k, v), L, \epsilon);
\]</span> and if a player, on observing the votes in the bundle, observes a bundle for some value (not necessarily distinct from the bundle’s value), <span class="math display">\[
N(S, L, \mathrm{Bundle}(r_k, p_k, s_k, v))
= (S&#39; \cup \mathrm{Bundle}(r_k, p_k, s_k, v), L&#39;,
   (\mathrm{Bundle}^*(r_, p_k, s_k, v&#39;), \ldots)).
\]</span></p>
<h2 id="proposals-1">Proposals</h2>
<p>On receiving a proposal <span class="math inline">\(\mathrm{Proposal}(v)\)</span> a player</p>
<ul>
<li>Relays <span class="math inline">\(\mathrm{Proposal}(v)\)</span> if <span class="math inline">\(\sigma(S, r+1, 0) = v\)</span>.</li>
<li>Ignores it if it is invalid.</li>
<li>Ignores it if <span class="math inline">\(\mathrm{Proposal}(v) \in P\)</span>.</li>
<li>Relays <span class="math inline">\(\mathrm{Proposal}(v)\)</span>, observes it, and then produces any consequent output, if <span class="math inline">\(v \in \{\sigma(S, r, p), \bar{v}, \mu(S, r, p)\}\)</span>.</li>
<li>Otherwise, ignores it.</li>
</ul>
<p>Specifically, if the player ignores a proposal, <span class="math display">\[
N(S, L, \mathrm{Proposal}(v)) = (S, L, \epsilon)
\]</span> while if a player relays the proposal <em>after</em> checking if it is valid, <span class="math display">\[
N(S, L, \mathrm{Proposal}(v))
= (S&#39; \cup \mathrm{Proposal}(v), L&#39;, (\mathrm{Proposal}^*(v), \ldots)).
\]</span></p>
<p>However, in the first condition above, the player relays <span class="math inline">\(\mathrm{Proposal}(v)\)</span> <em>without</em> checking if it is valid. Since the proposal has not been seen to be valid, the player cannot observe it yet, so <span class="math display">\[
N(S, L, \mathrm{Proposal}(v)) = (S, L, (\mathrm{Proposal}^*(v))).
\]</span> Note: An implementation may <em>buffer</em> a proposal in this case. Specifically, an implementation which relays a proposal without checking that it is valid may optionally choose to replay this event when it observes that a new round has begun (see <a href="#internal-transitions">below</a>). In this case, on the conclusion of a new round, this proposal is processed once again as input.</p>
<p>Implementations may store and relay fewer proposals than specified here to improve efficiency. However, implementations are always required to relay proposals which match the following proposal-values (where <span class="math inline">\(r\)</span> is the current round and <span class="math inline">\(p\)</span> is the current period):</p>
<ul>
<li><span class="math inline">\(\bar{v}\)</span></li>
<li><span class="math inline">\(\sigma(S, r, p), \sigma(S, r, p-1)\)</span></li>
<li><span class="math inline">\(\mu(S, r, p)\)</span> if <span class="math inline">\(\sigma(S, r, p)\)</span> is not set and <span class="math inline">\(\mu(S, r, p+1)\)</span> if <span class="math inline">\(\sigma(S, r, p+1)\)</span> is not set</li>
</ul>
<h1 id="internal-transitions">Internal Transitions</h1>
<p>After receiving message events, the player updates some components of its state.</p>
<h2 id="new-round">New Round</h2>
<p>When a player observes that a new round <span class="math inline">\((r, 0)\)</span> has begun, the player sets <span class="math inline">\(\bar{s}:= s, \bar{v}:= \bot, p := 0, s := 0\)</span>. Specifically, if a new round has begun, <span class="math display">\[
 N((r-i, p, s, \bar{s}, V, P, \bar{v}), L, \ldots)
 = ((r, 0, 0, s, V&#39;, P&#39;, \bot), L&#39;, \ldots)
\]</span> for some <span class="math inline">\(i &gt; 0\)</span>.</p>
<h2 id="new-period">New Period</h2>
<p>When a player observes that a new period <span class="math inline">\((r, p)\)</span> has begun, the player sets <span class="math inline">\(\bar{s}:= s, s := 0\)</span>. Also, the player sets <span class="math inline">\(\bar{v}:= v\)</span> if the player has observed <span class="math inline">\(\mathrm{Bundle}(r, p-1, s, v)\)</span> given some values <span class="math inline">\(s &gt; \mathit{cert}\)</span> (or <span class="math inline">\(s = \mathit{soft}\)</span>), <span class="math inline">\(v \neq \bot\)</span>; if none exist, the player sets <span class="math inline">\(\bar{v}:= \sigma(S, r, p-i)\)</span> if it exists, where <span class="math inline">\(p-i\)</span> was the player’s period immediately before observing the new period; and if none exist, the player does not update <span class="math inline">\(\bar{v}\)</span>.</p>
<p>In other words, if <span class="math inline">\(\mathrm{Bundle}(r, p-1, s, v) \in V&#39;\)</span> for some <span class="math inline">\(v \neq \bot, s &gt; \mathit{cert}\)</span> or <span class="math inline">\(s = \mathit{soft}\)</span>, <span class="math display">\[
 N((r, p-i, s, \bar{s}, V, P, \bar{v}), L, \ldots)
 = ((r, p, 0, s, V&#39;, P, v), L&#39;, \ldots);
\]</span> and otherwise, if <span class="math inline">\(\mathrm{Bundle}(r, p-1, s, \bot) \in V&#39;\)</span> for some <span class="math inline">\(s &gt; \mathit{cert}\)</span> with <span class="math inline">\(\sigma(S, r, p-i)\)</span> defined, <span class="math display">\[
 N((r, p-i, s, \bar{s}, V, P, \bar{v}), L, \ldots)
 = ((r, p, 0, s, V&#39;, P, \sigma(S, r, p-i)), L&#39;, \ldots);
\]</span> and otherwise <span class="math display">\[
 N((r, p-i, s, \bar{s}, V, P, \bar{v}), L, \ldots)
 = ((r, p, 0, s, V&#39;, P, \bar{v}), L&#39;, \ldots);
\]</span> for some <span class="math inline">\(i &gt; 0\)</span> (where <span class="math inline">\(S = (r, p-i, s, \bar{s}, V, P, \bar{v}))\)</span>.</p>
<h2 id="garbage-collection">Garbage Collection</h2>
<p>When a player observes that either a new round or a new period <span class="math inline">\((r, p)\)</span> has begun, then the player <em>garbage-collects</em> old state. In other words, <span class="math display">\[
 N((r-i, p-i, s, \bar{s}, V, P, \bar{v}), L, \ldots)
 = ((r, p, \bar{s}, 0, V&#39; \setminus V^*_{r, p}, P&#39; \setminus P^*_{r, p},
    \bar{v}), L, \ldots).
\]</span> where <span class="math display">\[
\begin{aligned}
V^*_{r, p}
 &amp;=    \{\mathrm{Vote}(I, r&#39;, p&#39;, \bar{s}, v) | \mathrm{Vote}\in V, r&#39; &lt; r\} \\
 &amp;\cup \{\mathrm{Vote}(I, r&#39;, p&#39;, \bar{s}, v) | \mathrm{Vote}\in V, r&#39; = r, p&#39; + 1 &lt; p\}
\end{aligned}
\]</span> and <span class="math inline">\(P^*_{r, p}\)</span> is defined similarly.</p>
<h2 id="new-step">New Step</h2>
<p>A player may also update its step after receiving a timeout event.</p>
<p>On observing a timeout event of <span class="math inline">\(2\lambda\)</span>, the player sets <span class="math inline">\(s := \mathit{cert}\)</span>.</p>
<p>On observing a timeout event of <span class="math inline">\(\max\{4\lambda, \Lambda\}\)</span>, the player sets <span class="math inline">\(s := \mathit{next}_0\)</span>.</p>
<p>On observing a timeout event of <span class="math inline">\(\max\{4\lambda, \Lambda\} + 2^{s_t}\lambda + r\)</span> where <span class="math inline">\(r \in [0, 2^{s_t}\lambda]\)</span> sampled uniformly at random, the player sets <span class="math inline">\(s := s_t\)</span>.</p>
<p>In other words, <span class="math display">\[
\begin{aligned}
  &amp;N((r, p, s, \bar{s}, V, P, \bar{v}), L, t(2\lambda, p))
 &amp;&amp;= ((r, p, \mathit{cert}, \bar{s}, V, P, \bar{v}), L&#39;, \ldots) \\
  &amp;N((r, p, s, \bar{s}, V, P, \bar{v}), L, t(\max\{4\lambda, \Lambda\}, p))
 &amp;&amp;= ((r, p, \mathit{next}_0, \bar{s}, V, P, \bar{v}), L&#39;, \ldots) \\
  &amp;N((r, p, s, \bar{s}, V, P, \bar{v}), L,
     t(\max\{4\lambda, \Lambda\} + 2^{s_t}\lambda + r, p))
 &amp;&amp;= ((r, p, s_t, \bar{s}, V, P, \bar{v}), L&#39;, \ldots).
 \end{aligned}
\]</span></p>
<h1 id="broadcast-rules">Broadcast Rules</h1>
<p>Upon observing messages or receiving timeout events, the player state machine emits network outputs, which are externally visible. The player may also append an entry to the ledger.</p>
<p>A correct player emits only valid votes. Suppose the player is identified with the address <span class="math inline">\(I\)</span> and possesses the secret key <span class="math inline">\(\mathrm{sk}\)</span>, and the agreement is occurring on the ledger <span class="math inline">\(L\)</span>. Then the player constructs a vote <span class="math inline">\(\mathrm{Vote}(I, r, p, s, v)\)</span> by doing the following:</p>
<ul>
<li><p>Let <span class="math inline">\((\mathrm{pk}, B) = \mathrm{Record}(L, r - \delta_b, I)\)</span>, <span class="math inline">\(\bar{B}= \mathrm{Stake}(L, r - \delta_b)\)</span>, <span class="math inline">\(Q = \mathrm{Seed}(L, r - \delta_s)\)</span>, <span class="math inline">\(\tau = \mathrm{CommitteeThreshold}(s)\)</span>, <span class="math inline">\(\bar{\tau}= \mathrm{CommitteeSize}(s).\)</span></p></li>
<li><p>Encode <span class="math inline">\(x := (I, r, p, s, v), x&#39; := (I, r, p, s).\)</span></p></li>
<li><p>Try to set <span class="math inline">\(y := \mathrm{Sign}(x, x&#39;, \mathrm{sk}, B, \bar{B}, Q, \tau, \bar{\tau}).\)</span></p></li>
</ul>
<p>If the signing procedure succeeds, the player broadcasts <span class="math inline">\(\mathrm{Vote}(I, r, p, s, v) = (I, r, p, s, v, y)\)</span>. Otherwise, the player does not broadcast anything.</p>
<p>For certain broadcast vote-messages specified here, a node is forbidden to <em>equivocate</em> (i.e., produce a pair of votes which contain the same round, period, and step but which vote for different proposal values). These messages are marked with an asterisk (*) below. To prevent accidental equivocation after a power failure, nodes should checkpoint their state to crash-safe storage before sending these messages.</p>
<h2 id="resynchronization-attempt">Resynchronization Attempt</h2>
<p>Where specified, a player attempts to resynchronize. A resynchronization attempt involves the following:</p>
<ul>
<li>First, the player broadcasts its <em>freshest bundle</em>, if one exists. A player’s freshest bundle is a complete bundle defined as follows:
<ul>
<li><span class="math inline">\(\mathrm{Bundle}(r, p, \mathit{soft}, v) \subset V\)</span> for some <span class="math inline">\(v\)</span>, if it exists, or else</li>
<li><span class="math inline">\(\mathrm{Bundle}(r, p-1, s, \bot) \subset V\)</span> for some <span class="math inline">\(s &gt; \mathit{cert}\)</span>, if it exists, or else</li>
<li><span class="math inline">\(\mathrm{Bundle}(r, p-1, s, v) \subset V\)</span> for some <span class="math inline">\(s &gt; \mathit{cert}, v \neq \bot\)</span>, if it exists.</li>
</ul></li>
<li>Second, if the player broadcasted a bundle <span class="math inline">\(\mathrm{Bundle}(r, p, s, v)\)</span>, and <span class="math inline">\(v \neq \bot\)</span>, then the player broadcasts <span class="math inline">\(\mathrm{Proposal}(v)\)</span> if the player has it.</li>
</ul>
<p>Specifically, a resynchronization attempt corresponds to no additional outputs if no freshest bundle exists <span class="math display">\[
N(S, L, \ldots) = (S&#39;, L&#39;, \ldots),
\]</span> corresponds to a broadcast of a bundle after a relay output and before any subsequent broadcast outputs, if a freshest bundle exists but no matching proposal exists <span class="math display">\[
N(S, L, \ldots) = (S&#39;, L&#39;, (\ldots, \mathrm{Bundle}^*(r, p, \mathit{soft}, v), \ldots)),
\]</span> and otherwise corresponds to a broadcast of both a bundle and a proposal after a relay output and before any subsequent broadcast outputs <span class="math display">\[
 N(S, L, \ldots) = (S&#39;, L&#39;,
    (\ldots, \mathrm{Bundle}^*(r, p, \mathit{soft}, v), \mathrm{Proposal}(v), \ldots)).
\]</span></p>
<h2 id="proposals-2">Proposals</h2>
<p>On observing that <span class="math inline">\((r, p)\)</span> has begun, the player attempts to resynchronize, and then</p>
<ul>
<li><p>if <span class="math inline">\(p = 0\)</span> or there exists some <span class="math inline">\(s &gt; \mathit{cert}\)</span> where <span class="math inline">\(\mathrm{Bundle}(r, p-1, s, \bot)\)</span> was observed, then a player generates a new proposal <span class="math inline">\((v&#39;, \mathrm{Proposal}(v&#39;))\)</span> and then broadcasts <span class="math inline">\((\mathrm{Vote}(I, r, p, 0, v&#39;), \mathrm{Proposal}(v&#39;))\)</span>.</p></li>
<li><p>if <span class="math inline">\(p &gt; 0\)</span> and there exists some <span class="math inline">\(s_0 &gt; \mathit{cert}, v\)</span> where <span class="math inline">\(\mathrm{Bundle}(r, p-1, s_0, v)\)</span> was observed, while there exists no <span class="math inline">\(s_1 &gt; \mathit{cert}\)</span> where <span class="math inline">\(\mathrm{Bundle}(r, p-1, s_1, \bot)\)</span> was observed, then the player broadcasts <span class="math inline">\(\mathrm{Vote}(I, r, p, 0, v)\)</span>. Moreover, if <span class="math inline">\(\mathrm{Proposal}(v) \in P\)</span>, the player then broadcasts <span class="math inline">\(\mathrm{Proposal}(v)\)</span>.</p></li>
</ul>
<p>A player generates a new proposal by executing the entry-generation procedure and by setting the fields of the proposal accordingly. Specifically, the player creates a proposal payload <span class="math inline">\(((o, s), y)\)</span> by setting <span class="math inline">\(o := \mathrm{Entry}(L), Q := \mathrm{Seed}(L, r-1)\)</span>, <span class="math inline">\(y := \mathrm{Sign}(Q, Q, 0, 0, 0, 0, 0, 0)\)</span>, and <span class="math inline">\(s := \mathrm{Rand}(y, \mathrm{pk})\)</span> if <span class="math inline">\(p = 0\)</span> and <span class="math inline">\(s := \mathrm{Hash}(\mathrm{Seed}(L, r-1))\)</span> otherwise. This consequently defines the matching proposal-value <span class="math inline">\(v = (I, p, \mathrm{Digest}(e), \mathrm{Hash}(\mathrm{Encoding}(e))).\)</span></p>
<p>In other words, if the player generates a new proposal, <span class="math display">\[
N(S, L, \ldots) = (S&#39;, L&#39;, (\ldots, \mathrm{Vote}(I, r, p, 0, v&#39;), \mathrm{Proposal}(v&#39;))),
\]</span> while if the player broadcasts an old proposal, <span class="math display">\[
N(S, L, \ldots) = (S&#39;, L&#39;, (\ldots, \mathrm{Vote}(I, r, p-1, 0, v), \mathrm{Proposal}(v)))
\]</span> if <span class="math inline">\(\mathrm{Proposal}(v) \in P\)</span> and <span class="math display">\[
N(S, L, \ldots) = (S&#39;, L&#39;, (\ldots, \mathrm{Vote}(I, r, p-1, 0, v)))
\]</span> otherwise.</p>
<h2 id="reproposal-payloads">Reproposal Payloads</h2>
<p>On observing <span class="math inline">\(\mathrm{Vote}(I, r, p, 0, v)\)</span>, if <span class="math inline">\(\mathrm{Proposal}(v) \in P\)</span> then the player broadcasts <span class="math inline">\(\mathrm{Proposal}(v)\)</span>.</p>
<p>In other words, if <span class="math inline">\(\mathrm{Proposal}(v) \in P\)</span>, <span class="math display">\[
N(S, L, \mathrm{Vote}(I, r, p, 0, v)) = (S&#39;, L&#39;, (\mathrm{Proposal}(v))).
\]</span></p>
<h2 id="filtering">Filtering</h2>
<p>On observing a timeout event of <span class="math inline">\(2\lambda\)</span> (where <span class="math inline">\(\mu = (H, H&#39;, l, p_\mu) = \mu(S, r, p)\)</span>),</p>
<ul>
<li><p>if <span class="math inline">\(\mu \neq \bot\)</span> and if</p>
<ul>
<li><span class="math inline">\(p_\mu = p\)</span> or</li>
<li>there exists some <span class="math inline">\(s &gt; \mathit{cert}\)</span> such that <span class="math inline">\(\mathrm{Bundle}(r, p-1, s, \mu)\)</span> was observed. then the player broadcasts <span class="math inline">\(\mathrm{Vote}(I, r, p, \mathit{soft}, \mu)\)</span>.</li>
</ul></li>
<li><p>if there exists some <span class="math inline">\(s_0 &gt; \mathit{cert}\)</span> such that <span class="math inline">\(\mathrm{Bundle}(r, p-1, s_0, \bar{v})\)</span> was observed and there exists no <span class="math inline">\(s_1 &gt; \mathit{cert}\)</span> such that <span class="math inline">\(\mathrm{Bundle}(r, p-1, s_1, \bot)\)</span> was observed, then the player broadcasts* <span class="math inline">\(\mathrm{Vote}(I, r, p, \mathit{soft}, \bar{v})\)</span>.</p></li>
<li><p>otherwise, the player does nothing.</p></li>
</ul>
<p>In other words, in the first case above, <span class="math display">\[
N(S, L, t(2\lambda, p)) = (S, L, \mathrm{Vote}(I, r, p, \mathit{soft}, \mu));
\]</span> while in the second case above, <span class="math display">\[
N(S, L, t(2\lambda, p)) = (S, L, \mathrm{Vote}(I, r, p, \mathit{soft}, \bar{v}));
\]</span> and if neither case is true, <span class="math display">\[
N(S, L, t(2\lambda, p)) = (S, L, \epsilon).
\]</span></p>
<h2 id="certifying">Certifying</h2>
<p>On observing that some proposal-value <span class="math inline">\(v\)</span> is committable for its current round <span class="math inline">\(r\)</span>, and some period <span class="math inline">\(p&#39; \geq p\)</span> (its current period), if <span class="math inline">\(s \leq \mathit{cert}\)</span>, then then the player broadcasts* <span class="math inline">\(\mathrm{Vote}(I, r, p, \mathit{cert}, v)\)</span>. (It can be shown that this occurs either after a proposal is received or a soft-vote, which can be part of a bundle, is received.)</p>
<p>In other words, if observing a soft-vote causes a proposal-value to become committable, <span class="math display">\[
 N(S, L, \mathrm{Vote}(I, r, p, \mathit{soft}, v))
 = (S&#39;, L, (\ldots, \mathrm{Vote}(I, r, p, \mathit{cert}, v)));
\]</span> while if observing a bundle causes a proposal-value to become committable, <span class="math display">\[
 N(S, L, \mathrm{Bundle}(r, p, \mathit{soft}, v))
 = (S&#39;, L, (\ldots, \mathrm{Vote}(I, r, p, \mathit{cert}, v)));
\]</span> and if observing a proposal causes a proposal-value to become committable, <span class="math display">\[
 N(S, L, \mathrm{Proposal}(v))
 = (S&#39;, L, (\ldots, \mathrm{Vote}(I, r, p, \mathit{cert}, v)));
\]</span> as long as <span class="math inline">\(s \leq \mathit{cert}\)</span>.</p>
<h2 id="commitment">Commitment</h2>
<p>On observing <span class="math inline">\(\mathrm{Bundle}(r, p, \mathit{cert}, v)\)</span> for some value <span class="math inline">\(v\)</span>, the player <em>commits</em> the entry <span class="math inline">\(e\)</span> corresponding to <span class="math inline">\(\mathrm{Proposal}(v)\)</span>; i.e., the player appends <span class="math inline">\(e\)</span> to the sequence of entries on its ledger <span class="math inline">\(L\)</span>. (Evidently, this occurs either after a vote is received or after a bundle is received.)</p>
<p>In other words, if observing a cert-vote causes the player to commit <span class="math inline">\(e\)</span>, <span class="math display">\[
 N(S, L, \mathrm{Vote}(I, r, p, \mathit{cert}, v))
 = (S&#39;, L || e, \ldots));
\]</span> while if observing a bundle causes the player to commit <span class="math inline">\(e\)</span>, <span class="math display">\[
 N(S, L, \mathrm{Bundle}(r, p, \mathit{cert}, v))
 = (S&#39;, L || e, \ldots)).
\]</span> Note: Occasionally, an implementation may not have <span class="math inline">\(e\)</span> at the point <span class="math inline">\(e\)</span> becomes committed. In this case, the implementation may wait until it receives <span class="math inline">\(e\)</span> somehow (perhaps by requesting peers for <span class="math inline">\(e\)</span>). Alternatively, the implementation may continue running the protocol until it receives <span class="math inline">\(e\)</span>. However, if the protocol chooses to continue running, it may not transmit any vote for which <span class="math inline">\(v \neq \bot\)</span> until it has committed <span class="math inline">\(e\)</span>.</p>
<h2 id="recovery">Recovery</h2>
<p>On observing a timeout event of</p>
<ul>
<li><span class="math inline">\(T = \max\{4\lambda, \Lambda\}\)</span> or</li>
<li><span class="math inline">\(T = \max\{4\lambda, \Lambda\} + 2^{s_t}\lambda + r\)</span> where <span class="math inline">\(r \in [0, 2^{s_t}\lambda]\)</span> sampled uniformly at random,</li>
</ul>
<p>the player attempts to resynchronize and then broadcasts* <span class="math inline">\(\mathrm{Vote}(I, r, p, \mathit{next}_s, v)\)</span> where</p>
<ul>
<li><span class="math inline">\(v = \sigma(S, r, p)\)</span> if <span class="math inline">\(v\)</span> is committable in <span class="math inline">\((r, p)\)</span>,</li>
<li><span class="math inline">\(v = \bar{v}\)</span> if there does not exist a <span class="math inline">\(s_0 &gt; \mathit{cert}\)</span> such that <span class="math inline">\(\mathrm{Bundle}(r, p-1, s_0, \bot)\)</span> was observed and there exists an <span class="math inline">\(s_1 &gt; \mathit{cert}\)</span> such that <span class="math inline">\(\mathrm{Bundle}(r, p-1, s_1, \bar{v})\)</span> was observed,</li>
<li>and <span class="math inline">\(v = \bot\)</span> otherwise.</li>
</ul>
<p>In other words, if a proposal-value <span class="math inline">\(v\)</span> is committable in the current period, <span class="math display">\[
N(S, L, t(T, p)) = (S&#39;, L, (\ldots, \mathrm{Vote}(I, r, p, \mathit{next}_s, v)));
\]</span> while in the second case, <span class="math display">\[
N(S, L, t(T, p)) = (S&#39;, L, (\ldots, \mathrm{Vote}(I, r, p, \mathit{next}_s, \bar{v})));
\]</span> and otherwise, <span class="math display">\[
N(S, L, t(T, p)) = (S&#39;, L, (\ldots, \mathrm{Vote}(I, r, p, \mathit{next}_s, \bot))).
\]</span></p>
<h2 id="fast-recovery">Fast Recovery</h2>
<p>On observing a timeout event of <span class="math inline">\(T = k\lambda_f + r\)</span> where <span class="math inline">\(k\)</span> is a positive integer and <span class="math inline">\(r \in [0, \lambda_f]\)</span> sampled uniformly at random, the player attempts to resynchronize. Then,</p>
<ul>
<li>The player broadcasts* <span class="math inline">\(\mathrm{Vote}(I, r, p, \mathit{late}, v)\)</span> if <span class="math inline">\(v = \sigma(S, r, p)\)</span> is committable in <span class="math inline">\((r, p)\)</span>.</li>
<li>The player broadcasts* <span class="math inline">\(\mathrm{Vote}(I, r, p, \mathit{redo}, \bar{v})\)</span> if there does not exist a <span class="math inline">\(s_0 &gt; \mathit{cert}\)</span> such that <span class="math inline">\(\mathrm{Bundle}(r, p-1, s_0, \bot)\)</span> was observed and there exists an <span class="math inline">\(s_1 &gt; \mathit{cert}\)</span> such that <span class="math inline">\(\mathrm{Bundle}(r, p-1, s_1, \bar{v})\)</span> was observed.</li>
<li>Otherwise, the player broadcasts* <span class="math inline">\(\mathrm{Vote}(I, r, p, \mathit{down}, \bot)\)</span>.</li>
</ul>
<p>Finally, the player broadcasts all <span class="math inline">\(\mathrm{Vote}(I, r, p, \mathit{late}, v) \in V\)</span>, all <span class="math inline">\(\mathrm{Vote}(I, r, p, \mathit{redo}, v) \in V\)</span>, and all <span class="math inline">\(\mathrm{Vote}(I, r, p, \mathit{down}, \bot) \in V\)</span> that it has observed.</p>
</body>
</html>
